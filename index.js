var grammar = [
    "start =",
    "    space? pipeline:pipeline { return pipeline; }",
    "",
    "pipeline =",
    "    ch:chunk '|' space? cons:pipeline { return [ch].concat(cons); }",
    "    / ch:chunk { return [ch]; }",
    "",
    "chunk =",
    "    cmd:command space? { return cmd; }",
    "    / sbsh:subshell space? { return sbsh; }",
    "",
    "command =",
    "    cmd:command_with_args { return cmd; }",
    "    / cmd:standalone_command { return cmd; }",
    "",
    "standalone_command =",
    "    ident:ident space? { return {type: 'command', command: ident, args: []}; }",
    "",
    "command_with_args = ",
    "    ident:ident space args:args { return {type: 'command', command: ident, args: args}; }",
    "",
    "args =",
    "    arg:arg space args:args { return [arg].concat(args); }",
    "    / arg:arg { return [arg]; }",
    "",
    "arg =",
    "    pair:pair { return pair; }",
    "    / atom:atom { return atom; }",
    "",
    "pair =",
    "    key:key ':' value:atom { return {type: 'pair', key: key, value: value}; }",
    "",
    "atom =",
    "    sw:switch { return sw; }",
    "    / bw:bare_word { return bw; }",
    "",
    "bare_word =",
    "    chars:[a-zA-Z0-9@_\\.-]+ { return {type: 'bare', text: chars.join('')}; }",
    "",
    "switch =",
    "    sign:[-+] ident:ident { return {type: 'switch', on: sign === '+', name: ident}; }",
    "",
    "key =",
    "    ident:ident { return ident; }",
    "",
    // TODO: should tolerate nested ) and be string-aware
    "subshell =",
    "    '$(' str:[^\)]* ')' { return {type: 'subshell', command: str.join('')}; }",
    "",
    "space =",
    "    [ \\t\\r\\n]+",
    "",
    "ident =",
    "    start:[a-zA-Z_] rest:[a-zA-Z0-9_]* { return start + rest.join(''); }"
].join("\n");

var parser = require('pegjs').buildParser(grammar);

module.exports = function(code) {
    return parser.parse(code);
}
